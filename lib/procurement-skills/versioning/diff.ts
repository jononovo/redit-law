import type { VendorSkill } from "../types";

export interface FieldDiff {
  field: string;
  label: string;
  type: "added" | "removed" | "changed" | "unchanged";
  oldValue: unknown;
  newValue: unknown;
  severity: "breaking" | "notable" | "minor";
}

export interface VersionDiff {
  fromVersion: string;
  toVersion: string;
  fields: FieldDiff[];
  breakingChanges: number;
  totalChanges: number;
  summary: string;
}

const FIELD_SEVERITY: Record<string, "breaking" | "notable" | "minor"> = {
  checkoutMethods: "breaking",
  capabilities: "breaking",
  methodConfig: "breaking",
  "search.pattern": "breaking",
  "search.urlTemplate": "breaking",
  "search.productIdFormat": "notable",
  "checkout.guestCheckout": "notable",
  "checkout.taxExemptField": "notable",
  "checkout.poNumberField": "notable",
  maturity: "notable",
  "shipping.freeThreshold": "minor",
  "shipping.estimatedDays": "minor",
  "shipping.businessShipping": "minor",
  tips: "minor",
  url: "notable",
  name: "minor",
  category: "notable",
  version: "minor",
  lastVerified: "minor",
  generatedBy: "minor",
  slug: "minor",
};

const FIELD_LABELS: Record<string, string> = {
  checkoutMethods: "Checkout Methods",
  capabilities: "Capabilities",
  methodConfig: "Method Configuration",
  "search.pattern": "Search Pattern",
  "search.urlTemplate": "Search URL Template",
  "search.productIdFormat": "Product ID Format",
  "checkout.guestCheckout": "Guest Checkout",
  "checkout.taxExemptField": "Tax Exempt Field",
  "checkout.poNumberField": "PO Number Field",
  maturity: "Maturity",
  "shipping.freeThreshold": "Free Shipping Threshold",
  "shipping.estimatedDays": "Estimated Delivery",
  "shipping.businessShipping": "Business Shipping",
  tips: "Tips",
  url: "URL",
  name: "Name",
  category: "Category",
  version: "Version",
  lastVerified: "Last Verified",
  generatedBy: "Generated By",
  slug: "Slug",
};

function flattenObject(obj: Record<string, unknown>, prefix = ""): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;
    if (value && typeof value === "object" && !Array.isArray(value)) {
      Object.assign(result, flattenObject(value as Record<string, unknown>, fullKey));
    } else {
      result[fullKey] = value;
    }
  }
  return result;
}

function arraysEqual(a: unknown[], b: unknown[]): boolean {
  if (a.length !== b.length) return false;
  const aStr = a.map(String).sort();
  const bStr = b.map(String).sort();
  return aStr.every((v, i) => v === bStr[i]);
}

function diffArrays(oldArr: unknown[], newArr: unknown[]): { added: unknown[]; removed: unknown[] } {
  const oldSet = new Set(oldArr.map(String));
  const newSet = new Set(newArr.map(String));
  const added = newArr.filter(v => !oldSet.has(String(v)));
  const removed = oldArr.filter(v => !newSet.has(String(v)));
  return { added, removed };
}

export function computeVersionDiff(
  oldSkill: VendorSkill,
  newSkill: VendorSkill,
  fromVersion: string,
  toVersion: string
): VersionDiff {
  const fields: FieldDiff[] = [];

  const topLevelArrays = ["checkoutMethods", "capabilities", "tips"];
  const topLevelObjects = ["search", "checkout", "shipping"];
  const topLevelScalars = ["name", "slug", "url", "category", "maturity", "version", "lastVerified", "generatedBy"];

  for (const key of topLevelArrays) {
    const oldVal = (oldSkill as any)[key] as unknown[] || [];
    const newVal = (newSkill as any)[key] as unknown[] || [];
    if (!arraysEqual(oldVal, newVal)) {
      const { added, removed } = diffArrays(oldVal, newVal);
      fields.push({
        field: key,
        label: FIELD_LABELS[key] || key,
        type: "changed",
        oldValue: oldVal,
        newValue: newVal,
        severity: FIELD_SEVERITY[key] || "minor",
      });
    }
  }

  for (const key of topLevelObjects) {
    const oldObj = flattenObject({ [key]: (oldSkill as any)[key] || {} });
    const newObj = flattenObject({ [key]: (newSkill as any)[key] || {} });
    const allKeys = new Set([...Object.keys(oldObj), ...Object.keys(newObj)]);

    for (const subKey of allKeys) {
      const oldVal = oldObj[subKey];
      const newVal = newObj[subKey];
      if (JSON.stringify(oldVal) !== JSON.stringify(newVal)) {
        let type: FieldDiff["type"] = "changed";
        if (oldVal === undefined) type = "added";
        else if (newVal === undefined) type = "removed";

        fields.push({
          field: subKey,
          label: FIELD_LABELS[subKey] || subKey,
          type,
          oldValue: oldVal,
          newValue: newVal,
          severity: FIELD_SEVERITY[subKey] || "minor",
        });
      }
    }
  }

  for (const key of topLevelScalars) {
    const oldVal = (oldSkill as any)[key];
    const newVal = (newSkill as any)[key];
    if (JSON.stringify(oldVal) !== JSON.stringify(newVal)) {
      let type: FieldDiff["type"] = "changed";
      if (oldVal === undefined) type = "added";
      else if (newVal === undefined) type = "removed";

      fields.push({
        field: key,
        label: FIELD_LABELS[key] || key,
        type,
        oldValue: oldVal,
        newValue: newVal,
        severity: FIELD_SEVERITY[key] || "minor",
      });
    }
  }

  const oldMethodFlat = flattenObject({ methodConfig: (oldSkill.methodConfig || {}) as Record<string, unknown> });
  const newMethodFlat = flattenObject({ methodConfig: (newSkill.methodConfig || {}) as Record<string, unknown> });
  const allMethodKeys = new Set([...Object.keys(oldMethodFlat), ...Object.keys(newMethodFlat)]);

  for (const subKey of allMethodKeys) {
    const oldVal = oldMethodFlat[subKey];
    const newVal = newMethodFlat[subKey];
    if (JSON.stringify(oldVal) !== JSON.stringify(newVal)) {
      let type: FieldDiff["type"] = "changed";
      if (oldVal === undefined) type = "added";
      else if (newVal === undefined) type = "removed";

      fields.push({
        field: subKey,
        label: FIELD_LABELS[subKey] || subKey,
        type,
        oldValue: oldVal,
        newValue: newVal,
        severity: FIELD_SEVERITY["methodConfig"] || "breaking",
      });
    }
  }

  const breakingChanges = fields.filter(f => f.severity === "breaking").length;
  const totalChanges = fields.length;

  const parts: string[] = [];
  if (breakingChanges > 0) parts.push(`${breakingChanges} breaking`);
  const notable = fields.filter(f => f.severity === "notable").length;
  if (notable > 0) parts.push(`${notable} notable`);
  const minor = fields.filter(f => f.severity === "minor").length;
  if (minor > 0) parts.push(`${minor} minor`);
  const summary = totalChanges === 0 ? "No changes" : parts.join(", ");

  return {
    fromVersion,
    toVersion,
    fields: fields.filter(f => f.type !== "unchanged"),
    breakingChanges,
    totalChanges,
    summary,
  };
}

export function detectChangedFields(oldSkill: VendorSkill, newSkill: VendorSkill): string[] {
  const diff = computeVersionDiff(oldSkill, newSkill, "", "");
  return diff.fields.map(f => f.field);
}

export function hasBreakingChanges(oldSkill: VendorSkill, newSkill: VendorSkill): boolean {
  const diff = computeVersionDiff(oldSkill, newSkill, "", "");
  return diff.breakingChanges > 0;
}
