# CreditClaw Procurement Skills â€” Technical Plan v2

## Overview

A procurement intelligence module that maintains a curated, self-improving library of vendor shopping skills. Three layers: a **Skill Builder** that auto-generates skills by crawling vendor sites, a **typed registry** with rich checkout taxonomy, and a **feedback loop** that improves skills from real agent usage.

---

## 1. Checkout Method Taxonomy

The registry's classification system. This replaces the simple `tier` field from v1.

```typescript
// lib/procurement-skills/types.ts

export type CheckoutMethod =
  | "native_api"           // Vendor has a programmatic ordering API (e.g., Amazon via CrossMint)
  | "acp"                  // Supports Stripe's Agentic Checkout Protocol
  | "x402"                 // Supports x402 payment protocol
  | "crossmint_world"     // CrossMint World Store (headless commerce)
  | "self_hosted_card"    // CreditClaw's split-knowledge card at standard checkout
  | "browser_automation"; // Requires full browser interaction (lowest tier)

export type VendorCapability =
  | "price_lookup"         // Can check prices programmatically
  | "stock_check"          // Can verify availability
  | "programmatic_checkout"// Can complete purchase without browser
  | "business_invoicing"   // Supports invoiced purchases / net terms
  | "bulk_pricing"         // Shows quantity-based discounts
  | "tax_exemption"        // Supports tax-exempt purchasing
  | "account_creation"     // Agent can create a business account
  | "order_tracking"       // Can poll for shipment status
  | "returns"              // Can initiate returns programmatically
  | "po_numbers";          // Accepts purchase order references

export type SkillMaturity = "verified" | "beta" | "community" | "draft";

export interface VendorSkill {
  slug: string;
  name: string;
  logoUrl?: string;
  category: "retail" | "office" | "hardware" | "electronics" | "industrial" | "specialty";
  url: string;

  // Rich checkout classification
  checkoutMethods: CheckoutMethod[];        // Ordered by preference (best first)
  capabilities: VendorCapability[];
  maturity: SkillMaturity;

  // Per-method config (only the methods listed above get entries)
  methodConfig: Partial<Record<CheckoutMethod, {
    locatorFormat?: string;                 // "amazon:{ASIN}" or "url:{product_url}"
    searchEndpoint?: string;                // CreditClaw endpoint if applicable
    requiresAuth: boolean;                  // Vendor account login needed?
    notes: string;
  }>>;

  search: {
    pattern: string;
    urlTemplate?: string;                   // "https://www.staples.com/search?query={q}"
    productIdFormat?: string;               // "ASIN", "SKU", "item number"
  };

  checkout: {
    guestCheckout: boolean;
    taxExemptField: boolean;
    poNumberField: boolean;
  };

  shipping: {
    freeThreshold?: number;
    estimatedDays: string;
    businessShipping: boolean;
  };

  tips: string[];

  // Versioning & feedback
  version: string;                          // semver
  lastVerified: string;                     // ISO date â€” last time a human confirmed it works
  generatedBy: "skill_builder" | "manual";
  feedbackStats?: {
    successRate: number;                    // 0-1, from agent usage logs
    lastFailure?: string;                   // ISO date
    failureReason?: string;
  };
}
```

---

## 2. Skill Builder (the hard part)

This is the tool that takes a vendor URL and produces a draft `VendorSkill` config. It's the key accelerator â€” without it, you're hand-authoring each vendor.

### Architecture

The builder runs as a server-side job (not a real-time API). It's expensive â€” multiple fetches, LLM calls, and possibly browser automation to test checkout flows.

```typescript
// lib/procurement-skills/builder/analyze.ts

export interface AnalysisResult {
  vendor: Partial<VendorSkill>;             // Draft config
  confidence: Record<string, number>;       // Per-field confidence 0-1
  evidence: AnalysisEvidence[];             // What the builder found and where
  warnings: string[];                       // Things a human should verify
}

interface AnalysisEvidence {
  field: string;                            // Which VendorSkill field this informs
  source: "robots_txt" | "meta_tags" | "structured_data" | "page_crawl" | "api_probe" | "llm_inference";
  url: string;
  snippet: string;                          // What was found
}

export async function analyzeVendor(url: string): Promise<AnalysisResult> {
  const results = await Promise.allSettled([
    probeForAPIs(url),
    analyzeCheckoutFlow(url),
    detectBusinessFeatures(url),
    checkProtocolSupport(url),
  ]);

  return mergeAnalysisResults(results);
}
```

### The four analysis passes

```typescript
// lib/procurement-skills/builder/probes.ts

/**
 * Pass 1: API & Protocol Detection
 * Checks whether the vendor supports any programmatic purchasing.
 * This determines the checkout method tier.
 */
async function probeForAPIs(url: string): Promise<Partial<AnalysisResult>> {
  const domain = new URL(url).hostname;

  // Check for well-known agentic commerce endpoints
  const probes = [
    // x402: look for 402 Payment Required + x402 headers
    fetch(`${url}/api/health`, { method: "HEAD" }).then(r => ({
      protocol: "x402" as const,
      found: r.status === 402 || r.headers.has("x-402-receipt"),
    })),

    // ACP: check for /.well-known/acp.json (Stripe's convention)
    fetch(`${url}/.well-known/acp.json`).then(r => ({
      protocol: "acp" as const,
      found: r.ok,
    })),

    // CrossMint: check if domain is in CrossMint's World Store catalog
    // (call CrossMint's API to see if they carry this merchant)
    checkCrossmintCatalog(domain).then(found => ({
      protocol: "crossmint_world" as const,
      found,
    })),

    // Look for public API docs (common patterns)
    ...["/developers", "/api-docs", "/developer/api", "/partner-api"].map(path =>
      fetch(`${url}${path}`, { redirect: "follow" }).then(r => ({
        protocol: "native_api" as const,
        found: r.ok && r.headers.get("content-type")?.includes("text/html"),
        url: `${url}${path}`,
      }))
    ),
  ];

  const results = await Promise.allSettled(probes);
  // ... merge into detected checkout methods, ordered by preference
}

/**
 * Pass 2: Checkout Flow Analysis
 * Uses LLM to analyze the checkout process from screenshots/HTML.
 * This is the most expensive pass â€” it fetches key pages and asks
 * Claude to identify form fields, payment options, and flow steps.
 */
async function analyzeCheckoutFlow(url: string): Promise<Partial<AnalysisResult>> {
  // Fetch key pages
  const pages = await Promise.allSettled([
    fetchAndExtract(`${url}`),                           // Homepage â€” search bar location
    fetchAndExtract(`${url}/cart`),                       // Cart page structure
    fetchAndExtract(`${url}/checkout`),                   // Checkout form fields
    fetchAndExtract(`${url}/business`),                   // Business account page
    fetchAndExtract(`${url}/business/register`),          // Business registration
  ]);

  // Send to Claude for structured extraction
  const analysis = await callClaude({
    system: `You are analyzing an e-commerce website for an AI procurement system.
Given the HTML content of key pages, extract:
1. Search: How does product search work? URL pattern? Search bar selector?
2. Checkout: What fields are on the checkout form? Guest checkout available?
   PO number field? Tax exemption field? What payment methods accepted?
3. Business: Is there a business account tier? What extra features does it offer?
4. Product IDs: What format are product identifiers? (SKU, item number, ASIN, etc.)

Return JSON matching the VendorSkill schema fields.`,
    content: pages
      .filter(p => p.status === "fulfilled")
      .map(p => p.value)
      .join("\n---\n"),
  });

  return parseClaudeAnalysis(analysis);
}

/**
 * Pass 3: Business Feature Detection
 * Specifically looks for B2B capabilities since these are
 * high-value differentiators for procurement.
 */
async function detectBusinessFeatures(url: string): Promise<Partial<AnalysisResult>> {
  // Check for common business-specific URL patterns
  const businessUrls = [
    `${url}/business`,
    `${url}/b2b`,
    `${url}/enterprise`,
    `${url}/tax-exempt`,
    `${url}/purchase-orders`,
    `${url}/net-terms`,
    `${url}/bulk-orders`,
  ];

  // Probe each, build capabilities list from what exists
  // ...
}

/**
 * Pass 4: Protocol Support
 * Checks for specific agentic payment protocol support.
 */
async function checkProtocolSupport(url: string): Promise<Partial<AnalysisResult>> {
  // Already handled in probeForAPIs, but this pass goes deeper:
  // - If ACP found, fetch the manifest and extract supported operations
  // - If x402 found, test what content types are paywalled
  // - Check for Stripe Checkout integration (indicator of possible ACP future support)
  // ...
}
```

### Builder Output â†’ Human Review â†’ Publish

The builder produces a draft with confidence scores. Low-confidence fields get flagged:

```typescript
// lib/procurement-skills/builder/publish.ts

export async function runSkillBuilder(url: string): Promise<{
  draft: VendorSkill;
  reviewNeeded: string[];      // Fields with confidence < 0.7
  autoPublish: boolean;        // True only if ALL fields > 0.9 confidence
}> {
  const analysis = await analyzeVendor(url);

  const reviewNeeded = Object.entries(analysis.confidence)
    .filter(([_, conf]) => conf < 0.7)
    .map(([field]) => field);

  return {
    draft: analysis.vendor as VendorSkill,
    reviewNeeded,
    autoPublish: reviewNeeded.length === 0 && 
      Object.values(analysis.confidence).every(c => c > 0.9),
  };
}
```

---

## 3. Feedback Loop

When agents use a skill and it fails, that data flows back to improve the skill.

```typescript
// lib/procurement-skills/feedback.ts

export interface SkillFeedbackEvent {
  vendorSlug: string;
  botId: string;
  eventType: "success" | "checkout_failed" | "search_failed" | "price_mismatch" | "out_of_stock" | "flow_changed";
  details?: string;              // Error message or description
  checkoutMethod: CheckoutMethod;
  timestamp: string;
}

/**
 * Called from the purchase endpoint when a vendor checkout
 * succeeds or fails. Aggregates into feedbackStats on the vendor.
 */
export async function recordSkillFeedback(event: SkillFeedbackEvent): Promise<void> {
  await storage.insertSkillFeedback(event);

  // Recalculate success rate for this vendor
  const recent = await storage.getSkillFeedback(event.vendorSlug, { days: 30 });
  const successRate = recent.filter(e => e.eventType === "success").length / recent.length;

  // Update the vendor's feedbackStats
  await storage.updateVendorFeedbackStats(event.vendorSlug, {
    successRate,
    lastFailure: event.eventType !== "success" ? event.timestamp : undefined,
    failureReason: event.eventType !== "success" ? event.eventType : undefined,
  });

  // If success rate drops below threshold, flag for review
  if (successRate < 0.7) {
    await notifySkillDegradation(event.vendorSlug, successRate);
  }
}
```

### DB additions (minimal â€” one table)

```typescript
// In shared/schema.ts

export const skillFeedback = pgTable("skill_feedback", {
  id: serial("id").primaryKey(),
  vendorSlug: text("vendor_slug").notNull(),
  botId: text("bot_id").notNull(),
  eventType: text("event_type").notNull(),
  checkoutMethod: text("checkout_method").notNull(),
  details: text("details"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});
```

---

## 4. Discovery API & Catalog Page

### Bot-facing API (same as v1, but richer filtering)

```
GET /api/v1/bot/skills
  ?category=hardware
  ?checkout=acp,crossmint_world       â† filter by checkout method
  ?capability=bulk_pricing,tax_exemption  â† filter by capability
  ?search=lowes
  ?maturity=verified,beta             â† exclude drafts/community
```

### Human-facing catalog page: `/skills`

Grid of vendor cards, grouped by category. Each card shows:
- Vendor name + logo
- Checkout method badges (color-coded: green for native_api, blue for ACP, etc.)
- Capability pills (bulk pricing, tax exempt, order tracking, etc.)
- Maturity badge (verified âœ“, beta ðŸ§ª, etc.)
- Success rate indicator if available
- Link to the rendered skill preview + raw SKILL.md download

Filter sidebar: category checkboxes, checkout method checkboxes, capability checkboxes, search box.

No auth required â€” this is public. It's both a discovery tool for agents and a marketing page for CreditClaw.

---

## 5. Vendor Launch Priority

| Phase | Vendors | Why |
|-------|---------|-----|
| **P0 (already live)** | Amazon, Shopify | Native via CrossMint |
| **P1 (build + verify)** | Walmart, Amazon Business, Staples, Home Depot, Lowe's | Highest volume procurement targets |
| **P2 (skill builder generates)** | Walmart Business, Office Depot, Uline, Grainger, Newegg, B&H Photo | Builder does first pass, humans verify |
| **P3 (community + long tail)** | McMaster-Carr, Fastenal, Chewy, iHerb, Zoro, etc. | Builder + community contributions |

---

## 6. What This Plan Doesn't Cover Yet

- **Account credential vault** â€” storing vendor logins per owner for business accounts
- **Price watch / caching** â€” periodic checks to track pricing trends
- **ClawHub packaging** â€” publishing each skill as a standalone ClawHub installable
- **Skill builder UI** â€” dashboard page where owners can request a new vendor analysis (for now, it's triggered manually or via internal tooling)